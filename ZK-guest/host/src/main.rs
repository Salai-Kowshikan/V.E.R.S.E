// // // These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// // // The ELF is used for proving and the ID is used for verification.
use methods::{
    LINEARREGRESSION_ELF, LINEARREGRESSION_ID
};

use std::fs;
// Testing signing key
fn main() {
    fs::write("LinearRegression_exported", LINEARREGRESSION_ELF)
    .expect("Failed to write ELF file");
    fs::write("LinearRegression_ID_exported", format!("{:?}", LINEARREGRESSION_ID))
        .expect("Failed to write ID file");
}



// use std::fs;
// use std::path::Path;
// use std::process::Command;
// use std::io::Write;
// use anyhow::Result;
// use rayon::prelude::*;

// // ---------- Split dataset into batches ----------
// fn split_into_batches<T: Clone>(data: &[T], batch_size: usize) -> Vec<Vec<T>> {
//     data.chunks(batch_size).map(|c| c.to_vec()).collect()
// }

// // ---------- Main ----------
// fn main() -> Result<()> {
//     println!("üöÄ Starting dataset embedding and ELF generation...");

//     // Step 1: Load dataset from file
//     let dataset_path = "../dataset.csv";
//     let content = fs::read_to_string(dataset_path)
//         .expect("‚ùå Failed to read dataset.csv");
//     let lines: Vec<&str> = content.lines().collect();

//     // Step 2: Split into batches (e.g., 75 per batch)
//     let batch_size = 75;
//     let batches = split_into_batches(&lines, batch_size);
//     println!("üì¶ Total {} batches created.", batches.len());

//     // Step 3: Create output folder
//     let output_dir = "../guest/target/batches";
//     fs::create_dir_all(output_dir)?;

//     // Step 4: For each batch
//     for (i, batch) in batches.iter().enumerate() {
//         let batch_num = i + 1;
//         println!("‚öôÔ∏è  Processing Batch {batch_num}...");

//         // Create temporary dataset file
//         let batch_dataset_path = format!("../guest/batch_dataset_{batch_num}.csv");
//         let mut f = fs::File::create(&batch_dataset_path)?;
//         for line in batch {
//             writeln!(f, "{}", line)?;
//         }

//         // Step 5: Embed this dataset into guest code (replace CSV path)
//         let guest_code_path = "../guest/src/main.rs";
//         let original_code = fs::read_to_string(guest_code_path)
//             .expect("‚ùå Failed to read guest main.rs");

//         let modified_code = original_code.replace(
//             "let csv_path = &args[1];",
//             &format!("let csv_path = \"batch_dataset_{batch_num}.csv\";")
//         );

//         fs::write(guest_code_path, modified_code)?;

//         // Step 6: Build guest ELF
//         println!("üèóÔ∏è  Building guest ELF for Batch {batch_num}...");
//         let status = Command::new("cargo")
//             .args(&["build", "--release", "--target", "riscv32im-risc0-zkvm-elf"])
//             .current_dir("../guest")
//             .status()
//             .expect("‚ùå Failed to build guest ELF");
//         assert!(status.success(), "‚ùå Cargo build failed for Batch {batch_num}");

//         // Step 7: Move ELF to batches folder
//         let elf_src = "../guest/target/riscv32im-risc0-zkvm-elf/release/guest";
//         let elf_dest = format!("{output_dir}/batch_{batch_num}.elf");
//         fs::copy(elf_src, &elf_dest)
//             .expect("‚ùå Failed to copy batch ELF");
//         println!("‚úÖ Batch {batch_num} ELF written to {elf_dest}");

//         // Step 8: Restore original guest code
//         fs::write(guest_code_path, original_code)?;
//     }

//     println!("üéâ All batches processed successfully!");
//     Ok(())
// }





// fn main() {

// //     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
// //     tracing_subscriber::fmt()
// //         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
// //         .init();

// //     // An executor environment describes the configurations for the zkVM
// //     // including program inputs.
// //     // A default ExecutorEnv can be created like so:
// //     // `let env = ExecutorEnv::builder().build().unwrap();`
// //     // However, this `env` does not have any inputs.
// //     //
// //     // To add guest input to the executor environment, use
// //     // ExecutorEnvBuilder::write().
// //     // To access this method, you'll need to use ExecutorEnv::builder(), which
// //     // creates an ExecutorEnvBuilder. When you're done adding input, call
// //     // ExecutorEnvBuilder::build().

// //     // For example:
// //     let a: f32 = 2.5;  // slope
// //     let b: f32 = 1.0;  // intercept
// //     let env = ExecutorEnv::builder()
// //         .write(&a)
// //         .unwrap()
// //         .write(&b)
// //         .unwrap()
// //         .build()
// //         .unwrap();

// //     // Obtain the default prover.
// //     let prover = default_prover();

// //     // Proof information by proving the specified ELF binary.
// //     // This struct contains the receipt along with statistics about execution of the guest
// //     let prove_info = prover
// //         .prove(env, LINEARREGRESSION_ELF)
// //         .unwrap();

// //     // extract the receipt.
// //     let receipt = prove_info.receipt;

// //     // TODO: Implement code for retrieving receipt journal here.

// //     // For example:
// //     let _output: u32 = receipt.journal.decode().unwrap();

// //     // The receipt was verified at the end of proving, but the below code is an
// //     // example of how someone else could verify this receipt.
// //     receipt
// //         .verify(LINEARREGRESSION_ID)
// //         .unwrap();
// // }

// use risc0_zkvm::{default_prover, ExecutorEnv};
// use std::fs;

// fn main() {
//     println!("Enter path to guest ELF file:");
//     let mut path = String::new();
//     io::stdin().read_line(&mut path).expect("Failed to read input");
//     let path = path.trim();
//     //let guest_elf = fs::read(path).expect("Failed to read ELF file");
//     let elf_bytes = fs::read(path).expect("shobhaaaaaa");
//     let guest_elf: &[u8] = &elf_bytes;

//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     println!("Hash id of LINEARREGRESSION_ELF: {:?}", LINEARREGRESSION_ID);
//     // An executor environment describes the configurations for the zkVM
//     // including program inputs.
//     // A default ExecutorEnv can be created like so:
//     // `let env = ExecutorEnv::builder().build().unwrap();`
//     // However, this `env` does not have any inputs.
//     //
//     // To add guest input to the executor environment, use
//     // ExecutorEnvBuilder::write().
//     // To access this method, you'll need to use ExecutorEnv::builder(), which
//     // creates an ExecutorEnvBuilder. When you're done adding input, call
//     // ExecutorEnvBuilder::build().
//     println!("Type of LINEARREGRESSION_ELF: {}", std::any::type_name_of_val(&LINEARREGRESSION_ELF));
//     println!("First 16 bytes of LINEARREGRESSION_ELF: {:?}", &LINEARREGRESSION_ELF[..16]);

//     // Read ELF from disk
//     let elf_bytes = fs::read("/home/kowshik/V.E.R.S.E/ZK-guest/LinearRegression_exported").unwrap();
//     let elf_slice: &[u8] = &elf_bytes;  // Convert Vec<u8> to &[u8]

//     // println!("Type of elf_slice: {}", std::any::type_name_of_val(&elf_slice));
    // fs::write("LinearRegression_exported", LINEARREGRESSION_ELF)
    //     .expect("Failed to write ELF file");

//     // For example:
//     let a: f32 = 2.5;  // slope
//     let b: f32 = 1.0;  // intercept
//     let env = ExecutorEnv::builder()
//         .write(&to_vec(&model_type).unwrap())
//         .unwrap()
//         .write(&to_vec(&weights).unwrap())
//         .unwrap()
//         .write(&to_vec(&b).unwrap())
//         .unwrap()
//         .build()
//         .unwrap();

//     let prover = default_prover();

//     // Proof information by proving the specified ELF binary.
//     // This struct contains the receipt along with statistics about execution of the guest
//     // let prove_info = prover
//     //     .prove(env, LINEARREGRESSION_ELF)
//     //     .unwrap();
//     // extract the receipt.
//     let prove_info = prover
//         .prove(env, elf_slice)
//         .unwrap();
//     let receipt = prove_info.receipt;

//     // TODO: Implement code for retrieving receipt journal here.

//     // For example:
//     let _output: u32 = receipt.journal.decode().unwrap();

//     println!("Got output: {_output}");

//     // The receipt was verified at the end of proving, but the below code is an
//     // example of how someone else could verify this receipt.
//     receipt
//         .verify(LINEARREGRESSION_ID)
//         .unwrap();
// }


// // use std::fs;
// // use risc0_zkvm::{default_prover, ExecutorEnv};

// // fn main() {
// //     // Load ELF bytes from file
// //     let elf_bytes = fs::read("/home/kowshik/V.E.R.S.E/ZK-guest/test/LinearRegression").unwrap();

// //     // Build execution environment
// //     let a: f32 = 2.5;
// //     let b: f32 = 1.0;
// //     let env = ExecutorEnv::builder()
// //         .write(&a).unwrap()
// //         .write(&b).unwrap()
// //         .build().unwrap();

// //     // Prove
// //     let prover = default_prover();
// //     let prove_info = prover.prove(env, &elf_bytes).unwrap();
// //     let receipt = prove_info.receipt;

// //     // Read output
// //     let output: u32 = receipt.journal.decode().unwrap();
// //     println!("Got output: {output}");

// //     // ‚ö†Ô∏è Verification needs the ImageID (hash of the ELF).
// //     // You can compute it at runtime like this:
// //     // let image_id = risc0_zkvm::compute_image_id(&elf_bytes).unwrap();
// //     // receipt.verify(image_id).unwrap();
// // }


