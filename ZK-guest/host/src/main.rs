// // These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// // The ELF is used for proving and the ID is used for verification.
// use methods::{
//     LINEARREGRESSION_ELF, LINEARREGRESSION_ID
// };
// use risc0_zkvm::{default_prover, ExecutorEnv};

// fn main() {
//     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     // An executor environment describes the configurations for the zkVM
//     // including program inputs.
//     // A default ExecutorEnv can be created like so:
//     // `let env = ExecutorEnv::builder().build().unwrap();`
//     // However, this `env` does not have any inputs.
//     //
//     // To add guest input to the executor environment, use
//     // ExecutorEnvBuilder::write().
//     // To access this method, you'll need to use ExecutorEnv::builder(), which
//     // creates an ExecutorEnvBuilder. When you're done adding input, call
//     // ExecutorEnvBuilder::build().

//     // For example:
//     let a: f32 = 2.5;  // slope
//     let b: f32 = 1.0;  // intercept
//     let env = ExecutorEnv::builder()
//         .write(&a)
//         .unwrap()
//         .write(&b)
//         .unwrap()
//         .build()
//         .unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Proof information by proving the specified ELF binary.
//     // This struct contains the receipt along with statistics about execution of the guest
//     let prove_info = prover
//         .prove(env, LINEARREGRESSION_ELF)
//         .unwrap();

//     // extract the receipt.
//     let receipt = prove_info.receipt;

//     // TODO: Implement code for retrieving receipt journal here.

//     // For example:
//     let _output: u32 = receipt.journal.decode().unwrap();

//     // The receipt was verified at the end of proving, but the below code is an
//     // example of how someone else could verify this receipt.
//     receipt
//         .verify(LINEARREGRESSION_ID)
//         .unwrap();
// }

use risc0_zkvm::{default_prover, ExecutorEnv};
use risc0_zkvm::serde::{to_vec, from_slice};
use serde_json;
use std::fs;
use std::io;

fn main() {
    println!("Enter path to guest ELF file:");
    let mut path = String::new();
    io::stdin().read_line(&mut path).expect("Failed to read input");
    let path = path.trim();
    //let guest_elf = fs::read(path).expect("Failed to read ELF file");
    let elf_bytes = fs::read(path).expect("shobhaaaaaa");
    let guest_elf: &[u8] = &elf_bytes;

    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    println!("Select model type (1=linear, 2=multiple, 3=polynomial, 4=logistic):");
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).expect("Failed to read model type");
    let model_type: u32 = buffer.trim().parse().expect("Please enter a valid number");

    println!("Enter weights (comma-separated, e.g., 1.0,2.0,3.0):");
    buffer.clear();
    io::stdin().read_line(&mut buffer).expect("Failed to read weights");
    let weights: Vec<f32> = buffer
        .trim()
        .split(',')
        .map(|s| s.parse::<f32>().expect("Invalid weight"))
        .collect();

    println!("Enter bias (b):");
    buffer.clear();
    io::stdin().read_line(&mut buffer).expect("Failed to read bias");
    let b: f32 = buffer.trim().parse().expect("Please enter a valid number");

    let env = ExecutorEnv::builder()
        .write(&to_vec(&model_type).unwrap())
        .unwrap()
        .write(&to_vec(&weights).unwrap())
        .unwrap()
        .write(&to_vec(&b).unwrap())
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, &guest_elf).unwrap();
    let receipt = prove_info.receipt;

let output: Vec<f32> = from_slice(receipt.journal.bytes.as_slice()).unwrap();

println!("\n======= Inference Results =======");
for (i, val) in output.iter().enumerate() {
    println!("Sample {} => {}", i + 1, val);
}
println!("================================\n");


    let proof_json = serde_json::to_string_pretty(&receipt).expect("Failed to serialize receipt");
    fs::write("proof.json", &proof_json).expect("Failed to write proof file");
    println!("âœ… Proof saved to proof.json");
}
