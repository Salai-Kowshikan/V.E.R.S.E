// // These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// // The ELF is used for proving and the ID is used for verification.
// use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
// use risc0_zkvm::{default_prover, ExecutorEnv};

// fn main() {
//     // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     // An executor environment describes the configurations for the zkVM
//     // including program inputs.
//     // A default ExecutorEnv can be created like so:
//     // `let env = ExecutorEnv::builder().build().unwrap();`
//     // However, this `env` does not have any inputs.
//     //
//     // To add guest input to the executor environment, use
//     // ExecutorEnvBuilder::write().
//     // To access this method, you'll need to use ExecutorEnv::builder(), which
//     // creates an ExecutorEnvBuilder. When you're done adding input, call
//     // ExecutorEnvBuilder::build().

//     // For example:
//     let input: u32 = 15 * u32::pow(2, 27) + 1;
//     let env = ExecutorEnv::builder()
//         .write(&input)
//         .unwrap()
//         .build()
//         .unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Proof information by proving the specified ELF binary.
//     // This struct contains the receipt along with statistics about execution of the guest
//     let prove_info = prover
//         .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
//         .unwrap();

//     // extract the receipt.
//     let receipt = prove_info.receipt;

//     // TODO: Implement code for retrieving receipt journal here.

//     // For example:
//     let _output: u32 = receipt.journal.decode().unwrap();

//     // The receipt was verified at the end of proving, but the below code is an
//     // example of how someone else could verify this receipt.
//     receipt
//         .verify(GUEST_CODE_FOR_ZK_PROOF_ID)
//         .unwrap();
// }



// hardcoded tree

// use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
// use risc0_zkvm::{default_prover, ExecutorEnv};
// use std::io::{self, Write};

// fn main() {
//     // Initialize tracing
//     tracing_subscriber::fmt()
//         .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
//         .init();

//     // 1️⃣ Read thresholds/weights from user
//     let mut thresholds: [f32; 3] = [0.0; 3];
//     let feature_names = [
//         "petal_length split for setosa",
//         "petal_width split versicolor/virginica",
//         "petal_length split versicolor/virginica",
//     ];

//     for i in 0..3 {
//         print!("Enter {}: ", feature_names[i]);
//         io::stdout().flush().unwrap();
//         let mut input = String::new();
//         io::stdin().read_line(&mut input).unwrap();
//         thresholds[i] = input.trim().parse::<f32>().expect("Invalid number");
//     }

//     // 2️⃣ Create executor environment with thresholds
//     let env = ExecutorEnv::builder()
//         .write(&thresholds)
//         .unwrap()
//         .build()
//         .unwrap();

//     // 3️⃣ Obtain default prover
//     let prover = default_prover();

//     // 4️⃣ Prove the computation in the guest ELF
//     let prove_info = prover
//         .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
//         .unwrap();

//     // 5️⃣ Extract the receipt
//     let receipt = prove_info.receipt;

//     // 6️⃣ Decode predictions from the journal
//     let (numeric_classes, class_indices): ([u32; 5], [u32; 5]) = receipt.journal.decode().unwrap();

//     // 7️⃣ Define class names and expected classes for the 5 hardcoded samples
//     let class_names = ["setosa", "versicolor", "virginica"];
//     let expected_classes = ["setosa", "setosa", "versicolor", "virginica", "virginica"];

//     // 8️⃣ Print predictions along with expected answers
//     println!("\nSample | Predicted (num) | Predicted (class) | Expected");
//     println!("---------------------------------------------------------");
//     for i in 0..5 {
//         println!(
//             "  {}    |       {}        |       {}         | {}",
//             i,
//             numeric_classes[i],
//             class_names[class_indices[i] as usize],
//             expected_classes[i]
//         );
//     }

//     // 9️⃣ Verify the receipt
//     receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap();
// }


use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Serialize, Deserialize};
use std::fs;

#[derive(Debug, Serialize, Deserialize)]
pub struct TreeNode {
    pub id: usize,
    pub feature: Option<usize>,            // null becomes None
    pub threshold: Option<f32>,            // null becomes None
    pub left: Option<usize>,               // -1 becomes None
    pub right: Option<usize>,              // -1 becomes None
    pub value: Option<Vec<Vec<f32>>>,      // matches the nested array
}

fn main() {
    // Load tree JSON from file
    let tree_json = fs::read_to_string("tree.json").expect("Failed to read tree.json");
    let tree: Vec<TreeNode> = serde_json::from_str(&tree_json).expect("Failed to parse tree.json");

    // Build zkVM environment
    let env = ExecutorEnv::builder()
        .write(&tree).unwrap()
        .build().unwrap();

    let prover = default_prover();
    let prove_info = prover
        .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
        .unwrap();

    let receipt = prove_info.receipt;

    // Decode predictions from guest
    let predictions: Vec<(u32, u32)> = receipt.journal.decode().unwrap();

    println!("Sample | Predicted | Expected");
    println!("------------------------------");
    for (i, (pred, expected)) in predictions.iter().enumerate() {
        println!("{:<6} | {:<9} | {}", i, pred, expected);
    }

    // Verify ZKP
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap();
    println!("✅ ZKP verified successfully");
}
